Why Flutter?
1.Object Oriented
2.A Fast Compiler
3.AOT(ahead-at-time) & JIT(Just-in-time)
4.strongly typed language
5.null sefty
6.hot relode
7.hot restart

**DataType**  
1.Number(integer
int age = 20;
,double
double a = 20.6)
2.string
string name = "Abhijit"
3.boolean
bool active = true
4.List
List myList = [2,8,3,7] //Like array same type first will 0 index collection of values
5.set
Set mySet ={"qaa","gd","yh","bvf",} //set is like object
6.map //set is like object or JSON object with key value pare dynamic is for any type can use
map<String,dynamic> myMap ={
'name' : 'abhijit',
'age' : 43
};
//dymanic means value of the key is not spacified like it may be string,bool,int
7.Rune => charcodes value convert in imoges

var is use there when we don't specify the datatype of a value
\*\*dart os statically type language
var b= "saha" //var is for when you not declare the data type
// top level function(from where code execution starts)

void main(){

}

**Operators**
Arithmetic
equality  
type test operator (is (return true or false) , is!(return false or true))
bitwise
assignment
logical
conditional (? : , ?? (null checker))

**Conditional statement**
if else if,else ,switch

**loops**
for
for in
for-each
while
do-while

**List/Array**

Growable List

**Map**
map

**Enum**<custom datatype>
Enumeration - Enum

**Runtime error vs Compiletime Error**
cyntex error is Compiletime Error
after compilation and run error is Runtime error

**Function**
define a function
calling a function
parameterized a function
arrow a function //default return
returning a function
optional positional parameter
optional link parameter
hire order function
functional programming

**Object Oriented programming**
Class => blueprint of schema of a object
Object => instance of class
constructor => same name of class
static => in a class you can make a vareable or function static so no need to make object to access those vereable or function  
Ingeritance =>
void main(){
var son = Son();
print(son.age);
print(son.name);
sone.methodOne();
}
class Father{
int age =50;
methodOne(){
print("abhijit");
}
int age =500;
methodTwo(){
print("saha");
}
}
class Son extend Father {
int name = "wqwqw";
}
Polymorphism => method overloading and method over riding
method overriding => change any function or value in perent class from child class
void main(){
var son = Son();
print(son.age);
print(son.name);
sone.methodOne();
}
class Father{
int age =50;
methodOne(){
print("abhijit");
}
int age =500;
methodTwo(){
print("saha");
}
}
class Son extend Father {
int name = "wqwqw";
@override
methodOne(){
print("method overriding");
}
}
Abstraction
Encapsulation
Interface

Asynchronous programming
Exception Handling

**Youtube**
Afran Sarkar
Baaba Devs
Codepur
Ahirlog
Rabbil Hasan
